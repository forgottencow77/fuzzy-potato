<!doctype html>
<html lang="ja">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/ol@7.5.2/ol.css"
  crossorigin="anonymous"
/>
<title>å·¦å³ç¸¦é…ç½®ï¼ˆå¤©æ°—ï¼æ™‚è¨ˆï¼ã‚»ãƒ³ã‚µãƒ¼ï¼‰</title>
<style>
  :root{
    --bg:#121212; --fg:#f0f0f0; --muted:#aaa; --card:#1e1e1e; --panel:#2a2a2a; --border:#333; --accent:#00bfff;
  }
  /* ===== ãƒ™ãƒ¼ã‚¹ ===== */
  html, body { background:var(--bg); color:var(--fg); }
  body{ font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:0; }
  h1{ text-align:center; font-size:1.1rem; margin:16px 0 8px; color:#fff; }

  .layout{
    display:grid;
    grid-template-columns: 120px 1fr 120px;
    gap:12px;
    padding:12px;
    max-width: 940px;
    margin: 0 auto 24px;
  }
  @media (max-width:480px){
    .layout{ grid-template-columns: 96px 1fr 96px; }
  }

  .panel{
    background:var(--card);
    border-radius:16px;
    box-shadow:0 8px 24px rgba(255,255,255,.08);
    padding:12px;
    height:100%;
    min-height:0;           /* å†…éƒ¨ã¯ã¿å‡ºã—é˜²æ­¢ */
    display:flex;
    flex-direction:column;
    gap:10px;
  }
  .title{ text-align:center; font-weight:700; color:#e6e6e6; font-size:.95rem; }
  .muted{ color:var(--muted); }

  .vstack{ display:flex; flex-direction:column; gap:10px; align-items:stretch; min-height:0; }
  .wx-item{
    border:1px solid var(--border); background:var(--panel); border-radius:12px; padding:10px 8px;
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    min-height:70px;
    flex:1 1 auto;          /* é«˜ã•ã®ã‚„ã‚Šãã‚Š */
  }
  .wx-emoji{ font-size:1.8rem; line-height:1; }
  .wx-label{ font-size:.8rem; color:var(--muted); margin-top:6px; }

  .arrow{ display:flex; align-items:center; justify-content:center; color:#ddd; opacity:.9; }
  .arrow svg{ width:18px; height:18px; fill:#ddd; }

  .center{ display:flex; flex-direction:column; gap:12px; justify-content:flex-start; align-items:stretch; min-height:0; }
  .map-wrapper{
    border:1px solid var(--border);
    background:var(--panel);
    border-radius:16px;
    padding:12px;
    display:flex;
    flex-direction:column;
    gap:8px;
  }
  #map{
    width:100%;
    min-height:300px;
    border-radius:12px;
    overflow:hidden;
  }
  #map-status{ text-align:center; }
  #alert-status{
    text-align:center;
    color:#ffb347;
    font-weight:700;
    min-height:1.2em;
  }
  .datetime{
    display:flex;
    flex-direction:column;
    gap:4px;
    align-items:center;
    justify-content:flex-start;
    color:var(--muted);
  }
  #date{
    font-size:1.1rem;
    text-align:center;
    margin:0;
  }
  #clock{
    font-size:3rem;
    font-weight:700;
    color:#00bfff;
    letter-spacing:2px;
    white-space:nowrap;
    text-align:center;
  }

  .kv{
    border:1px solid var(--border); background:var(--panel); border-radius:12px; padding:12px;
    text-align:center;
    flex:1 1 auto;          /* é«˜ã•å¯å¤‰ */
    display:flex; flex-direction:column; justify-content:center;
  }
  .kv .k{ color:var(--muted); font-size:.9rem; }
  .kv .v{ font-size:1.4rem; font-weight:700; color:#00bfff; margin-top:4px; }

  /* ===== éŸ³å£°ãƒªãƒƒã‚¹ãƒ³ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆ ===== */
  .listener-widget{
    position:fixed;
    right:16px;
    bottom:calc(env(safe-area-inset-bottom, 0) + 16px);
    display:flex;
    gap:10px;
    align-items:center;
    padding:10px 12px;
    background:rgba(18,18,18,0.95);
    border:1px solid var(--border);
    border-radius:16px;
    box-shadow:0 10px 30px rgba(0,0,0,0.35);
    z-index:1200;
  }
  .listener-btn{
    width:56px; height:56px;
    border-radius:50%;
    border:none;
    font-size:1.4rem;
    font-weight:700;
    cursor:pointer;
    color:#000;
    transition: transform 0.12s ease, box-shadow 0.12s ease;
  }
  .listener-btn.is-off{ background:#f05454; box-shadow:0 6px 12px rgba(240,84,84,0.35); }
  .listener-btn.is-on { background:#1bd760; box-shadow:0 6px 12px rgba(27,215,96,0.35); }
  .listener-btn:hover{ transform: translateY(-1px); }
  .playback-btn{
    width:44px; height:44px;
    border-radius:12px;
    border:1px solid var(--border);
    background:var(--panel);
    color:#f5f5f5;
    font-size:1.1rem;
    cursor:pointer;
    transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease;
  }
  .playback-btn:hover{ transform: translateY(-1px); background:#222; box-shadow:0 6px 14px rgba(0,0,0,0.35); }
  .playback-btn:active{ transform: translateY(0); }
  .listener-text{ display:flex; flex-direction:column; gap:4px; }
  .listener-status{ color:var(--muted); font-size:0.9rem; }
  .listener-reply{ color:var(--fg); font-size:0.95rem; min-height:1.2em; max-width:52vw; }

  /* ã‚¹ãƒãƒ›å¹…ã§å°‘ã—å¤§ãã‚ã«ã‚¿ãƒƒãƒ—ã—ã‚„ã™ã */
  @media (max-width: 820px){
    .listener-btn{ width:64px; height:64px; font-size:1.5rem; }
    .playback-btn{ width:52px; height:52px; font-size:1.2rem; }
    .listener-reply{ max-width:68vw; }
    body{ padding-bottom:120px; }
  }

  /* ======== landscapeï¼ˆæ¨ªå‘ãï¼‰ã§å·¦å³ã‚«ãƒ¼ãƒ‰ã‚’å°ã•ãï¼†æ­£æ–¹å½¢ ======== */
  @media (orientation: landscape){
    /* 1ç”»é¢ã«åã‚ã‚‹ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç¦æ­¢ & å®‰å…¨é ˜åŸŸè€ƒæ…®ï¼‰ */
    html, body{ height:100svh; overflow:hidden; }
    body{
      padding: env(safe-area-inset-top, 0) env(safe-area-inset-right, 0)
               env(safe-area-inset-bottom, 0) env(safe-area-inset-left, 0);
    }

    /* æ­£æ–¹å½¢ã‚«ãƒ¼ãƒ‰ã®åŸºæº–ã‚µã‚¤ã‚ºï¼ˆvhå„ªå…ˆã§è‡ªå‹•ç¸®å°ã€vwã§ã‚‚ä¸Šé™ï¼‰ */
    :root{
      --side-card-vh: clamp(64px, 13.0vh, 120px);
      --side-card-size: min(18vw, var(--side-card-vh));
    }

    /* ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼šå·¦å³ã‚’ã‚„ã‚„ç‹­ã‚ã€ä¸­å¤®ã¯å¯å¤‰ */
    .layout{
      height:100%;
      max-width:none; margin:0;
      grid-template-columns: clamp(110px, 19vw, 220px) 1fr clamp(110px, 19vw, 220px);
      gap: 1.2vh;
      padding: 1.2vh;
    }

    .panel{
      border-radius: 1.2vh;
      padding: 1.0vh;
      gap: 1.0vh;
      box-shadow: 0 0.8vh 2.2vh rgba(255,255,255,.08);
      min-height:0; overflow:hidden;
    }

    /* ===== å·¦å³ãƒ‘ãƒãƒ«ã®ä¸­èº«ï¼šæ­£æ–¹å½¢åŒ– ===== */
    aside.panel.vstack{ align-items:center; }  /* æ­£æ–¹å½¢ã‚’ä¸­å¤®å¯„ã› */

    /* å¤©æ°—ï¼ˆç¾åœ¨ï¼30åˆ†å¾Œï¼1æ™‚é–“å¾Œï¼‰ */
    .wx-item{
      width: var(--side-card-size);
      aspect-ratio: 1 / 1;           /* æ­£æ–¹å½¢ï¼ */
      padding: min(1.1vh, 10px);
      display:flex; flex-direction:column; justify-content:center; align-items:center;
      flex: 0 0 auto;                /* ä¼¸ã³ç¸®ã¿ç¦æ­¢ */
    }

    /* ã‚»ãƒ³ã‚µãƒ¼ï¼ˆæ°—æ¸©ï¼æ¹¿åº¦ï¼‰ */
    #sensor-panel .kv{
      width: var(--side-card-size);
      aspect-ratio: 1 / 1;           /* æ­£æ–¹å½¢ï¼ */
      padding: min(1.1vh, 10px);
      display:flex; flex-direction:column; justify-content:center; align-items:center;
      flex: 0 0 auto;
    }

    /* ã‚¿ã‚¤ãƒˆãƒ«ãƒ»è£œåŠ©æ–‡å­—ã¯è‡ªå‹•ç¸®å° */
    .title{ font-size: clamp(0.9rem, 1.3vh, 1.05rem); text-align:center; }
    .muted, .kv .k, .wx-label{ font-size: clamp(0.72rem, 1.1vh, 0.95rem); text-align:center; }

    /* çµµæ–‡å­—ãƒ»æ•°å€¤ã¯æ­£æ–¹å½¢å†…ã§è¦‹ã‚„ã™ã */
    .wx-emoji{ font-size: clamp(1.1rem, 3vh, 2rem); line-height:1; }
    .kv .v{ font-size: clamp(1.0rem, 2.8vh, 1.7rem); margin-top: 0.3em; }

    /* çŸ¢å°ã¯çœã‚¹ãƒšãƒ¼ã‚¹ */
    .arrow{ height:auto; }
    .arrow svg{ width: min(2vh, 16px); height: min(2vh, 16px); }

    /* ä¸­å¤®ï¼ˆæ™‚è¨ˆï¼‰ã¯æ®‹ã‚Šã‚¹ãƒšãƒ¼ã‚¹ã§å¯å¤‰ */
    .center{ justify-content:flex-start; align-items:stretch; min-height:0; }
    .map-wrapper{ padding:min(1.3vh, 12px); border-radius:12px; }
    #map{ min-height:240px; }
    .datetime{ align-items:center; }
    .datetime #date{ font-size: clamp(0.9rem, 1.5vh, 1.1rem); }
    .datetime #clock{ font-size: clamp(1.8rem, 6vh, 3.2rem); letter-spacing: clamp(0.06rem, 0.35vh, 0.16rem); white-space:nowrap; }
  }
</style>
<body>

  <div class="layout">
    <!-- å·¦ï¼šå¤©æ°— -->
    <aside class="panel vstack">
      <div class="title" id="wx-location">å¤©æ°—æƒ…å ±ã‚’å–å¾—ä¸­...</div>
      <div id="wx-status" class="muted" style="text-align:center;">ä½ç½®æƒ…å ±ã‚’å–å¾—ä¸­â€¦</div>

      <div class="wx-item">
        <div class="wx-emoji" id="wx-now-emoji">--</div>
        <div class="wx-label">ç¾åœ¨</div>
      </div>

      <div class="arrow" aria-hidden="true">
        <svg viewBox="0 0 24 24"><path d="M12 5v14M12 19l-4-4m4 4l4-4"/></svg>
      </div>

      <div class="wx-item">
        <div class="wx-emoji" id="wx-30m-emoji">--</div>
        <div class="wx-label">30åˆ†å¾Œ</div>
      </div>

      <div class="arrow" aria-hidden="true">
        <svg viewBox="0 0 24 24"><path d="M12 5v14M12 19l-4-4m4 4l4-4"/></svg>
      </div>

      <div class="wx-item">
        <div class="wx-emoji" id="wx-1h-emoji">--</div>
        <div class="wx-label">1æ™‚é–“å¾Œ</div>
      </div>
    </aside>

    <!-- ä¸­å¤®ï¼šæ—¥ä»˜ãƒ»æ™‚è¨ˆ -->
    <main class="panel center">
      <div class="datetime">
        <div id="date">----å¹´--æœˆ--æ—¥ (--)</div>
        <div id="clock">--:--:--</div>
      </div>
      <div class="map-wrapper">
        <div id="map"></div>
        <div id="map-status" class="muted">GPSèª­ã¿è¾¼ã¿ä¸­â€¦</div>
        <div id="alert-status"></div>
      </div>
    </main>

    <!-- å³ï¼šã‚»ãƒ³ã‚µãƒ¼ -->
    <aside class="panel vstack" id="sensor-panel">
      <div class="kv"><div class="k">æ°—æ¸©(â„ƒ)</div><div class="v" id="temp-v">--</div></div>
      <div class="kv"><div class="k">æ¹¿åº¦(%)</div><div class="v" id="humi-v">--</div></div>
      <div class="kv"><div class="k">æµ·æŠœ(m)</div><div class="v" id="alt-v">--</div></div>
      <div class="muted" style="text-align:center;">æ›´æ–°: <code id="ts">-</code></div>
      <div id="status" class="muted" style="text-align:center;">èª­ã¿è¾¼ã¿ä¸­â€¦</div>
    </aside>
  </div>

  <!-- å¸¸æ™‚ãƒªãƒƒã‚¹ãƒ³ç”¨ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
  <div class="listener-widget" id="listener-widget">
    <button id="listener-btn" class="listener-btn is-off" aria-label="éŸ³å£°ãƒªãƒƒã‚¹ãƒ³åˆ‡æ›¿">ğŸ™ï¸</button>
    <button id="playback-btn" class="playback-btn" aria-label="ç›´è¿‘ã®è¿”ç­”ã‚’å†ç”Ÿ">ğŸ”ˆ</button>
    <div class="listener-text">
      <div id="listener-status" class="listener-status">åœæ­¢ä¸­</div>
      <div id="listener-reply" class="listener-reply">-</div>
    </div>
    <audio id="assistant-audio" playsinline hidden autoplay></audio>
  </div>

  <script
    src="https://cdn.jsdelivr.net/npm/ol@7.5.2/dist/ol.js"
    crossorigin="anonymous"
  ></script>
  <script>
    /* ===== è¨­å®š ===== */
    const API_BASE = window.location.origin;
    const USER_ID  = "02";
    const FIELDS   = "temperature_c,humidity_percent,altitude_m";
    const RANGE    = "-30d";
    const GPS_FIELDS = "latitude,longitude";
    const GPS_RANGE  = "-1h";
    const MAP_ANIMATION_MS = 600;
    const HAZARD_THRESHOLD_M = 150; // æ¥è¿‘åˆ¤å®š
    const HAZARDS = [
      { name: "æ³¨æ„ãƒã‚¤ãƒ³ãƒˆ", lat: 35.38992744781368, lon: 139.4315005656078 },
    ];

    /* â–¼â–¼â–¼ ç¥å¥ˆå·çœŒè—¤æ²¢å¸‚ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä½ç½®ã«è¨­å®š â–¼â–¼â–¼ */
    const FUJISAWA = { lat: 35.3389, lon: 139.4913 };
    const FALLBACK_PLACE = "ç¥å¥ˆå·çœŒè—¤æ²¢å¸‚";
    /* â–²â–²â–² ã“ã“ã¾ã§ â–²â–²â–² */

    /* ===== æ™‚è¨ˆ ===== */
    const dateEl = document.getElementById("date");
    const clockEl = document.getElementById("clock");
    function updateClock(){
      const now = new Date();
      const yyyy = now.getFullYear();
      const mm = String(now.getMonth()+1).padStart(2,"0");
      const dd = String(now.getDate()).padStart(2,"0");
      const days = ["æ—¥","æœˆ","ç«","æ°´","æœ¨","é‡‘","åœŸ"];
      const hh = String(now.getHours()).padStart(2,"0");
      const mi = String(now.getMinutes()).padStart(2,"0");
      const ss = String(now.getSeconds()).padStart(2,"0");
      dateEl.textContent = `${yyyy}å¹´${mm}æœˆ${dd}æ—¥ (${days[now.getDay()]})`;
      clockEl.textContent = `${hh}:${mi}:${ss}`;
    }
    setInterval(updateClock, 1000); updateClock();

    /* ===== å¤©æ°—ï¼ˆOpen-Meteo + Nominatimï¼‰ ===== */
    const wxLocation = document.getElementById("wx-location");
    const wxStatus = document.getElementById("wx-status");
    const nowEmoji = document.getElementById("wx-now-emoji");
    const m30Emoji = document.getElementById("wx-30m-emoji");
    const h1Emoji  = document.getElementById("wx-1h-emoji");

    function codeToEmoji(code){
      const c = Number(code);
      if ([0].includes(c)) return "â˜€ï¸";
      if ([1].includes(c)) return "ğŸŒ¤ï¸";
      if ([2].includes(c)) return "â›…ï¸";
      if ([3].includes(c)) return "â˜ï¸";
      if ([45,48].includes(c)) return "ğŸŒ«ï¸";
      if ([51,53,55,56,57].includes(c)) return "ğŸŒ¦ï¸";
      if ([61,63,65,80,81,82].includes(c)) return "ğŸŒ§ï¸";
      if ([71,73,75,77,85,86].includes(c)) return "â„ï¸";
      if ([95,96,99].includes(c)) return "â›ˆï¸";
      return "â“";
    }

    // å–å¾—æˆåŠŸã§ã‚‚ç²¾åº¦ãŒæ‚ªã‘ã‚Œã°è—¤æ²¢å¸‚ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    const ACCURACY_THRESHOLD_M = 10000;
    function getPositionOrFallback(){
      return new Promise((resolve)=>{
        if(!navigator.geolocation) return resolve(FUJISAWA);
        navigator.geolocation.getCurrentPosition(
          pos => {
            const { latitude, longitude, accuracy } = pos.coords || {};
            if (typeof accuracy !== "number" || !isFinite(accuracy) || accuracy > ACCURACY_THRESHOLD_M) {
              resolve(FUJISAWA);
            } else {
              resolve({ lat: latitude, lon: longitude });
            }
          },
          ()  => resolve(FUJISAWA),
          { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 }
        );
      });
    }

    async function reverseGeocodeJapanese(lat, lon){
      try{
        const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}&accept-language=ja`;
        const data = await fetch(url).then(r=>r.json());
        const a = data.address || {};
        return a.city || a.town || a.village || a.suburb || a.county || a.state || FALLBACK_PLACE;
      }catch{ return FALLBACK_PLACE; }
    }

    async function fetchWeather(){
      try{
        wxStatus.textContent = "ä½ç½®æƒ…å ±ã‚’å–å¾—ä¸­â€¦";
        const {lat, lon} = await getPositionOrFallback();
        const place = await reverseGeocodeJapanese(lat, lon);
        wxLocation.textContent = `${place}ã®å¤©æ°—`;
        wxStatus.textContent = "å¤©æ°—ã‚’å–å¾—ä¸­â€¦";

        const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=weather_code&hourly=weather_code&timezone=auto`;
        const j = await fetch(url).then(r=>r.json());

        const cur = j.current?.weather_code;
        nowEmoji.textContent  = codeToEmoji(cur);

        const times = j.hourly?.time || [];
        const codes = j.hourly?.weather_code || [];
        const now = new Date();
        const target30 = new Date(now.getTime() + 30*60*1000);
        const target60 = new Date(now.getTime() + 60*60*1000);
        const idx30 = times.findIndex(t => new Date(t) >= target30);
        const idx60 = times.findIndex(t => new Date(t) >= target60);
        m30Emoji.textContent = (idx30 >= 0) ? codeToEmoji(codes[idx30]) : "â€”";
        h1Emoji.textContent  = (idx60 >= 0) ? codeToEmoji(codes[idx60])  : "â€”";

        wxStatus.textContent = "OK";
      }catch(e){
        wxStatus.textContent = "å¤©æ°—å–å¾—ã‚¨ãƒ©ãƒ¼: " + e.message;
        nowEmoji.textContent = m30Emoji.textContent = h1Emoji.textContent = "â“";
      }
    }

    /* ===== ãƒãƒƒãƒ—ï¼ˆGPSåº§æ¨™ï¼‰ ===== */
    function ensureMarkerStyle(color="#00bfff", stroke="#083150"){
      if (!window.ol) return null;
      return new ol.style.Style({
        image: new ol.style.Circle({
          radius: 8,
          fill: new ol.style.Fill({ color }),
          stroke: new ol.style.Stroke({ color: stroke, width: 2 }),
        }),
      });
    }

    function createMap(lngLat){
      const center = ol.proj.fromLonLat(lngLat);
      markerLayer = new ol.layer.Vector({ source: new ol.source.Vector() });
      hazardLayer = new ol.layer.Vector({ source: new ol.source.Vector() });
      mapInstance = new ol.Map({
        target: mapEl,
        layers: [
          new ol.layer.Tile({ source: new ol.source.OSM() }),
          hazardLayer,
          markerLayer,
        ],
        view: new ol.View({
          center,
          zoom: 16,
          minZoom: 2,
          maxZoom: 19,
        }),
        controls: ol.control.defaults.defaults({ attribution: true }),
      });
      markerFeature = new ol.Feature({ geometry: new ol.geom.Point(center) });
      markerStyle = ensureMarkerStyle("#00bfff", "#083150");
      markerFeature.setStyle(markerStyle);
      markerLayer.getSource().addFeature(markerFeature);
      // å±é™ºåœ°ç‚¹ãƒ”ãƒ³ï¼ˆèµ¤ï¼‰
      hazardStyle = ensureMarkerStyle("#ff5252", "#7a0e0e");
      HAZARDS.forEach(h => {
        const f = new ol.Feature({ geometry: new ol.geom.Point(ol.proj.fromLonLat([h.lon, h.lat])) });
        f.setStyle(hazardStyle);
        hazardLayer.getSource().addFeature(f);
      });
    }

    function updateMapView(lat, lon){
      if (!window.ol || !mapEl){
        if (mapStatus){
          mapStatus.textContent = "ãƒãƒƒãƒ—ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’èª­ã¿è¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸ";
        }
        return;
      }
      const lngLat = [Number(lon), Number(lat)];
      if (!mapInstance){
        createMap(lngLat);
        return;
      }
      const coords = ol.proj.fromLonLat(lngLat);
      const view = mapInstance.getView();
      view.animate({ center: coords, duration: MAP_ANIMATION_MS });
      if (!markerFeature){
        markerFeature = new ol.Feature({ geometry: new ol.geom.Point(coords) });
        if (!markerStyle) markerStyle = ensureMarkerStyle("#00bfff", "#083150");
        markerFeature.setStyle(markerStyle);
        markerLayer.getSource().addFeature(markerFeature);
      }else{
        markerFeature.getGeometry().setCoordinates(coords);
      }
      updateAlert(lat, lon);
    }

    function updateDeviceMarker(lat, lon){
      if (!window.ol || !mapEl) return;
      const lngLat = [Number(lon), Number(lat)];
      const coords = ol.proj.fromLonLat(lngLat);
      if (!mapInstance){ createMap(lngLat); }
      if (!deviceMarkerFeature){
        deviceMarkerFeature = new ol.Feature({ geometry: new ol.geom.Point(coords) });
        deviceMarkerStyle = ensureMarkerStyle("#7CFC00", "#0a3");
        deviceMarkerFeature.setStyle(deviceMarkerStyle);
        markerLayer.getSource().addFeature(deviceMarkerFeature);
      }else{
        deviceMarkerFeature.getGeometry().setCoordinates(coords);
      }
      if (mapInstance){
        mapInstance.getView().animate({ center: coords, duration: MAP_ANIMATION_MS });
      }
      updateAlert(lat, lon);
    }

    /* ç«¯æœ«ã®GPSã‚’ç›£è¦–ã—ã¦ãƒãƒƒãƒ—ã¨åŒæœŸ */
    const deviceGeo = { watchId: null, lastTs: null };
    function startDeviceWatch(){
      if (!navigator.geolocation) {
        deviceStatusText = "ç«¯æœ«GPSæœªå¯¾å¿œ";
        refreshMapStatus();
        return;
      }
      deviceStatusText = "ç«¯æœ«GPSå¾…æ©Ÿä¸­â€¦";
      refreshMapStatus();
      deviceGeo.watchId = navigator.geolocation.watchPosition(
        (pos)=>{
          const { latitude, longitude, accuracy } = pos.coords || {};
          if (latitude == null || longitude == null) return;
          updateDeviceMarker(latitude, longitude);
          deviceGeo.lastTs = pos.timestamp || Date.now();
          const accText = (typeof accuracy === "number" && isFinite(accuracy)) ? `Â±${Math.round(accuracy)}m` : "";
          deviceStatusText = `ç«¯æœ«GPS: ${formatTimeHMS(deviceGeo.lastTs)} ${accText}`;
          refreshMapStatus();
        },
        (err)=>{
          deviceStatusText = `ç«¯æœ«GPSã‚¨ãƒ©ãƒ¼: ${err.message}`;
          refreshMapStatus();
        },
        { enableHighAccuracy: true, maximumAge: 2000, timeout: 7000 }
      );
    }
    async function fetchGps(){
      if (!mapStatus) return;
      serverStatusText = "ã‚µãƒ¼ãƒãƒ¼GPSèª­è¾¼ä¸­â€¦";
      refreshMapStatus();
      try{
        const url = `${API_BASE}/api/latest_gps?user_id=${encodeURIComponent(USER_ID)}&fields=${encodeURIComponent(GPS_FIELDS)}&time_range=${encodeURIComponent(GPS_RANGE)}`;
        const res = await fetch(url);
        if(!res.ok) throw new Error(`${res.status} ${res.statusText}`);
        const json = await res.json();

        const { lat, lon, timestamp } = json;
        if (lat == null || lon == null) throw new Error("åº§æ¨™ãŒå–å¾—ã§ãã¾ã›ã‚“");
        updateMapView(Number(lat), Number(lon));
        serverStatusText = `ã‚µãƒ¼ãƒãƒ¼GPS: ${formatTimeToJP(timestamp)}`;
        refreshMapStatus();
      }catch(e){
        serverStatusText = "ã‚µãƒ¼ãƒãƒ¼GPSã‚¨ãƒ©ãƒ¼: " + e.message;
        refreshMapStatus();
      }
    }

    /* ===== ã‚»ãƒ³ã‚µãƒ¼æƒ…å ± ===== */
    const statusEl = document.getElementById("status");
    const tsEl     = document.getElementById("ts");
    const tempV    = document.getElementById("temp-v");
    const humiV    = document.getElementById("humi-v");
    const altV     = document.getElementById("alt-v");
    const mapEl    = document.getElementById("map");
    const mapStatus = document.getElementById("map-status");
    const alertStatus = document.getElementById("alert-status");
    let mapInstance = null;
    let markerLayer = null;
    let markerFeature = null;       // ã‚µãƒ¼ãƒãƒ¼å´ã®æœ€æ–°ä½ç½®
    let markerStyle = null;
    let deviceMarkerFeature = null; // ç«¯æœ«ã®ç¾åœ¨åœ°
    let deviceMarkerStyle = null;
    let hazardLayer = null;
    let hazardStyle = null;
    let lastWarningAt = 0;
    let serverStatusText = "";
    let deviceStatusText = "";
    let lastAlert = { hazard: null, inside: false, ts: 0 };

    function formatTimeToJP(ts) {
      if (!ts) return "-";
      const d = new Date(ts);
      if (isNaN(d)) return ts;
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const dd = String(d.getDate()).padStart(2, "0");
      const hh = String(d.getHours()).padStart(2, "0");
      const mi = String(d.getMinutes()).padStart(2, "0");
      return `${yyyy}/${mm}/${dd} ${hh}:${mi}æ™‚ç‚¹`;
    }
    function formatTimeHMS(ts){
      const d = new Date(ts);
      if (isNaN(d)) return "-";
      const hh = String(d.getHours()).padStart(2, "0");
      const mi = String(d.getMinutes()).padStart(2, "0");
      const ss = String(d.getSeconds()).padStart(2, "0");
      return `${hh}:${mi}:${ss}`;
    }
    function refreshMapStatus(){
      if (!mapStatus) return;
      const items = [];
      if (deviceStatusText) items.push(deviceStatusText);
      if (serverStatusText) items.push(serverStatusText);
      mapStatus.textContent = items.join(" | ") || "ä½ç½®æƒ…å ±å¾…æ©Ÿä¸­â€¦";
    }
    function haversineMeters(lat1, lon1, lat2, lon2){
      const R = 6371000; // m
      const toRad = (d)=>d*Math.PI/180;
      const dLat = toRad(lat2-lat1);
      const dLon = toRad(lon2-lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      const c = 2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }
    function updateAlert(lat, lon){
      if (!alertStatus) return;
      let nearest = null;
      let minDist = Infinity;
      HAZARDS.forEach(h=>{
        const d = haversineMeters(lat, lon, h.lat, h.lon);
        if (d < minDist){ minDist = d; nearest = h; }
      });
      if (!nearest){
        alertStatus.textContent = "";
        lastAlert.inside = false;
        return;
      }
      if (minDist <= HAZARD_THRESHOLD_M){
        const text = `âš ï¸ ${nearest.name} ã¾ã§ç´„ ${Math.round(minDist)}m: æ¸›é€Ÿã—å®‰å…¨ã‚’ç¢ºä¿ã—ã¦ãã ã•ã„`;
        alertStatus.textContent = text;
        if (!lastAlert.inside || lastAlert.hazard !== nearest.name){
          lastAlert.inside = true;
          lastAlert.hazard = nearest.name;
          lastAlert.ts = Date.now();
          playWarningTts("ã“ã®å…ˆã®è·¯é¢ã«å±é™ºãƒã‚¤ãƒ³ãƒˆãŒã‚ã‚Šã¾ã™ã€‚æ³¨æ„ã—ã¦ãŠé€²ã¿ãã ã•ã„ã€‚");
        }
      }else{
        alertStatus.textContent = "";
        lastAlert.inside = false;
      }
    }
    async function playWarningTts(text){
      const now = Date.now();
      if (now - lastWarningAt < 20_000) return; // 20ç§’ä»¥å†…ã®é€£ç¶šå†ç”Ÿã‚’æŠ‘åˆ¶
      lastWarningAt = now;
      try{
        const res = await fetch(`${API_BASE}/api/tts`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text }),
        });
        if (!res.ok) throw new Error(`${res.status} ${await res.text()}`);
        const data = await res.json();
        if (!data.audio_base64) throw new Error("audio missing");
        const url = `data:${data.audio_mime || "audio/wav"};base64,${data.audio_base64}`;
        assistantAudio.hidden = false;
        assistantAudio.src = url;
        await assistantAudio.play();
      }catch(err){
        console.warn("warning tts failed", err);
      }
    }

    async function fetchLatest(){
      statusEl.textContent = "èª­ã¿è¾¼ã¿ä¸­â€¦";
      try{
        const url = `${API_BASE}/api/latest?user_id=${encodeURIComponent(USER_ID)}&fields=${encodeURIComponent(FIELDS)}&time_range=${encodeURIComponent(RANGE)}`;
        const res = await fetch(url);
        if(!res.ok) throw new Error(`${res.status} ${res.statusText}`);
        const json = await res.json();

        tsEl.textContent  = formatTimeToJP(json.timestamp);

        const data = json.data || {};
        if (data.temperature_c != null) tempV.textContent = Number(data.temperature_c).toFixed(1);
        else tempV.textContent = "â€”";
        if (data.humidity_percent != null) humiV.textContent = Math.round(Number(data.humidity_percent));
        else humiV.textContent = "â€”";
        if (data.altitude_m != null) altV.textContent = Number(data.altitude_m).toFixed(1);
        else altV.textContent = "â€”";

        statusEl.textContent = "OK";
      }catch(e){
        statusEl.textContent = "ã‚¨ãƒ©ãƒ¼: " + e.message;
        tempV.textContent = humiV.textContent = altV.textContent = "â€”";
      }
    }

    /* ===== å¸¸æ™‚ãƒªãƒƒã‚¹ãƒ³ï¼ˆVADã§è‡ªå‹•åŒºåˆ‡ã‚Šé€ä¿¡ï¼‰ ===== */
    const listenerBtn = document.getElementById("listener-btn");
    const listenerStatus = document.getElementById("listener-status");
    const listenerReply = document.getElementById("listener-reply");
    const assistantAudio = document.getElementById("assistant-audio");

    const vadConfig = { threshold: 0.03, minSpeechMs: 200, minSilenceMs: 700 };
    const state = {
      listening: false,
      triggered: false,
      speechMs: 0,
      silenceMs: 0,
      frameMs: 0,
      segmentBuffers: [],
      audioContext: null,
      processor: null,
      source: null,
      stream: null,
      sampleRate: 16000,
      sending: false,
    };

    function setStatus(msg){ if (listenerStatus) listenerStatus.textContent = msg; }
    function setButton(listening){
      if (!listenerBtn) return;
      listenerBtn.classList.toggle("is-on", listening);
      listenerBtn.classList.toggle("is-off", !listening);
    }

    function mergeBuffers(buffers){
      const totalLength = buffers.reduce((sum, buf)=>sum + buf.length, 0);
      const result = new Float32Array(totalLength);
      let offset = 0;
      for (const buf of buffers){ result.set(buf, offset); offset += buf.length; }
      return result;
    }
    function floatTo16BitPCM(float32Array){
      const buffer = new ArrayBuffer(float32Array.length * 2);
      const view = new DataView(buffer);
      for (let i = 0; i < float32Array.length; i++){
        let s = Math.max(-1, Math.min(1, float32Array[i]));
        view.setInt16(i * 2, s < 0 ? s * 0x8000 : s * 0x7fff, true);
      }
      return buffer;
    }
    function encodeWav(samples, sampleRate){
      const buffer = new ArrayBuffer(44 + samples.length * 2);
      const view = new DataView(buffer);
      const pcmBuffer = floatTo16BitPCM(samples);
      function w(off,str){ for(let i=0;i<str.length;i++) view.setUint8(off+i, str.charCodeAt(i)); }
      w(0,"RIFF"); view.setUint32(4, 36 + samples.length * 2, true);
      w(8,"WAVE"); w(12,"fmt "); view.setUint32(16,16,true); view.setUint16(20,1,true);
      view.setUint16(22,1,true); view.setUint32(24,sampleRate,true); view.setUint32(28,sampleRate*2,true);
      view.setUint16(32,2,true); view.setUint16(34,16,true); w(36,"data"); view.setUint32(40,samples.length*2,true);
      const wavBytes = new Uint8Array(buffer); wavBytes.set(new Uint8Array(pcmBuffer), 44);
      return new Blob([wavBytes], { type: "audio/wav" });
    }

    async function sendSegment(buffers){
      if (!buffers.length) return;
      const merged = mergeBuffers(buffers);
      if (!merged.length) return;
      const wavBlob = encodeWav(merged, state.sampleRate);
      setStatus("é€ä¿¡ä¸­â€¦");
      try{
        const formData = new FormData();
        formData.append("file", wavBlob, "recording.wav");
        const res = await fetch(`${API_BASE}/api/assistant/talk`, { method: "POST", body: formData });
        if(!res.ok){
          const msg = await res.text();
          throw new Error(msg || `HTTP ${res.status}`);
        }
        const data = await res.json();
        listenerReply.textContent = data.reply || "(å¿œç­”ãªã—)";
        setStatus(data.message || "å®Œäº†");
        if (data.audio_base64){
          const dataUrl = `data:${data.audio_mime || "audio/wav"};base64,${data.audio_base64}`;
          assistantAudio.hidden = false;
          assistantAudio.src = dataUrl;
          const playPromise = assistantAudio.play();
          if (playPromise){
            playPromise.catch(()=>{
              assistantAudio.muted = true;
              assistantAudio.play().then(()=>{ setTimeout(()=>{ assistantAudio.muted = false; },150); }).catch(()=>{});
            });
          }
        }
      }catch(err){
        setStatus("ã‚¨ãƒ©ãƒ¼: " + err.message);
      }
    }

    function resetVad(){
      state.triggered = false;
      state.speechMs = 0;
      state.silenceMs = 0;
      state.segmentBuffers = [];
    }

    function finalizeSegment(){
      if (state.speechMs < vadConfig.minSpeechMs) { resetVad(); return; }
      const buffers = state.segmentBuffers.slice();
      resetVad();
      void sendSegment(buffers);
    }

    async function startListening(){
      if (state.listening) return;
      try{
        const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(stream);
        const processor = audioContext.createScriptProcessor(4096,1,1);
        state.stream = stream; state.audioContext = audioContext; state.source = source; state.processor = processor;
        state.sampleRate = audioContext.sampleRate;
        state.frameMs = (processor.bufferSize / state.sampleRate) * 1000;
        resetVad();
        processor.onaudioprocess = (event)=>{
          const channelData = event.inputBuffer.getChannelData(0);
          // RMS
          let sumSquares = 0; for (let i=0;i<channelData.length;i++){ const s=channelData[i]; sumSquares += s*s; }
          const rms = Math.sqrt(sumSquares / channelData.length);
          const isSpeech = rms >= vadConfig.threshold;
          if (isSpeech){
            state.segmentBuffers.push(new Float32Array(channelData));
            state.speechMs += state.frameMs;
            state.silenceMs = 0;
            if (!state.triggered && state.speechMs >= vadConfig.minSpeechMs){
              state.triggered = true;
              setStatus("éŸ³å£°æ¤œå‡ºä¸­â€¦");
            }
          } else {
            if (state.triggered){
              state.silenceMs += state.frameMs;
              if (state.silenceMs >= vadConfig.minSilenceMs){
                setStatus("ç„¡éŸ³â†’é€ä¿¡");
                finalizeSegment();
              }
            } else {
              // keep idle
              state.speechMs = 0;
            }
          }
        };
        source.connect(processor);
        processor.connect(audioContext.destination);
        state.listening = true;
        setButton(true);
        setStatus("å¾…æ©Ÿä¸­ (è©±ã—ã‹ã‘ã¦ãã ã•ã„)");
        listenerReply.textContent = "-";
      }catch(err){
        setStatus("ãƒã‚¤ã‚¯å–å¾—å¤±æ•—: " + err.message);
        stopListening();
      }
    }

    function stopListening(){
      if (state.processor){ state.processor.disconnect(); state.processor.onaudioprocess = null; }
      if (state.source){ state.source.disconnect(); }
      if (state.stream){ state.stream.getTracks().forEach(t=>t.stop()); }
      if (state.audioContext){ state.audioContext.close(); }
      state.processor = state.source = state.stream = state.audioContext = null;
      state.listening = false;
      resetVad();
      setButton(false);
      setStatus("åœæ­¢ä¸­");
    }

    if (listenerBtn){
      listenerBtn.addEventListener("click", async ()=>{
        if (state.listening){
          stopListening();
        }else{
          setButton(true);
          setStatus("ãƒã‚¤ã‚¯æ¥ç¶šä¸­â€¦");
          await startListening();
        }
      });
    }
    const playbackBtn = document.getElementById("playback-btn");
    if (playbackBtn){
      playbackBtn.addEventListener("click", ()=>{
        if (!assistantAudio || !assistantAudio.src){
          setStatus("å†ç”Ÿã§ãã‚‹éŸ³å£°ãŒã‚ã‚Šã¾ã›ã‚“");
          return;
        }
        assistantAudio.muted = false;
        assistantAudio.play().catch(err=>{
          setStatus("å†ç”Ÿã‚¨ãƒ©ãƒ¼: " + err.message);
        });
      });
    }

    document.addEventListener("DOMContentLoaded", ()=>{
      fetchWeather(); fetchLatest(); fetchGps(); startDeviceWatch();
      window._timer_sensor  = setInterval(fetchLatest, 30_000);
      window._timer_weather = setInterval(fetchWeather, 300_000);
      window._timer_gps     = setInterval(fetchGps, 60_000);
    });
  </script>
</body>
</html>
