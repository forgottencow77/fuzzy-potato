<!doctype html>
<html lang="ja">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/ol@7.5.2/ol.css"
  crossorigin="anonymous"
/>
<title>å·¦å³ç¸¦é…ç½®ï¼ˆå¤©æ°—ï¼æ™‚è¨ˆï¼ã‚»ãƒ³ã‚µãƒ¼ï¼‰</title>
<style>
  :root{
    --bg:#121212; --fg:#f0f0f0; --muted:#aaa; --card:#1e1e1e; --panel:#2a2a2a; --border:#333; --accent:#00bfff;
  }
  /* ===== ãƒ™ãƒ¼ã‚¹ ===== */
  html, body { background:var(--bg); color:var(--fg); }
  body{ font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:0; }
  h1{ text-align:center; font-size:1.1rem; margin:16px 0 8px; color:#fff; }

  .layout{
    display:grid;
    grid-template-columns: 120px 1fr 120px;
    gap:12px;
    padding:12px;
    max-width: 940px;
    margin: 0 auto 24px;
  }
  @media (max-width:480px){
    .layout{ grid-template-columns: 96px 1fr 96px; }
  }

  .panel{
    background:var(--card);
    border-radius:16px;
    box-shadow:0 8px 24px rgba(255,255,255,.08);
    padding:12px;
    height:100%;
    min-height:0;           /* å†…éƒ¨ã¯ã¿å‡ºã—é˜²æ­¢ */
    display:flex;
    flex-direction:column;
    gap:10px;
  }
  .title{ text-align:center; font-weight:700; color:#e6e6e6; font-size:.95rem; }
  .muted{ color:var(--muted); }

  .vstack{ display:flex; flex-direction:column; gap:10px; align-items:stretch; min-height:0; }
  .wx-item{
    border:1px solid var(--border); background:var(--panel); border-radius:12px; padding:10px 8px;
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    min-height:70px;
    flex:1 1 auto;          /* é«˜ã•ã®ã‚„ã‚Šãã‚Š */
  }
  .wx-emoji{ font-size:1.8rem; line-height:1; }
  .wx-label{ font-size:.8rem; color:var(--muted); margin-top:6px; }

  .arrow{ display:flex; align-items:center; justify-content:center; color:#ddd; opacity:.9; }
  .arrow svg{ width:18px; height:18px; fill:#ddd; }

  .center{ display:flex; flex-direction:column; gap:12px; justify-content:flex-start; align-items:stretch; min-height:0; }
  .map-wrapper{
    border:1px solid var(--border);
    background:var(--panel);
    border-radius:16px;
    padding:12px;
    display:flex;
    flex-direction:column;
    gap:8px;
  }
  #map{
    width:100%;
    min-height:300px;
    border-radius:12px;
    overflow:hidden;
  }
  #map-status{ text-align:center; }
  .datetime{
    display:flex;
    flex-direction:column;
    gap:4px;
    align-items:center;
    justify-content:flex-start;
    color:var(--muted);
  }
  #date{
    font-size:1.1rem;
    text-align:center;
    margin:0;
  }
  #clock{
    font-size:3rem;
    font-weight:700;
    color:#00bfff;
    letter-spacing:2px;
    white-space:nowrap;
    text-align:center;
  }

  .kv{
    border:1px solid var(--border); background:var(--panel); border-radius:12px; padding:12px;
    text-align:center;
    flex:1 1 auto;          /* é«˜ã•å¯å¤‰ */
    display:flex; flex-direction:column; justify-content:center;
  }
  .kv .k{ color:var(--muted); font-size:.9rem; }
  .kv .v{ font-size:1.4rem; font-weight:700; color:#00bfff; margin-top:4px; }

  .assistant-box{
    border:1px solid var(--border);
    background:var(--panel);
    border-radius:12px;
    padding:10px;
    display:flex;
    flex-direction:column;
    gap:8px;
  }
  .assistant-box button{
    border:none;
    border-radius:12px;
    padding:12px;
    font-size:1rem;
    font-weight:600;
    background:var(--accent);
    color:#000;
    cursor:pointer;
  }
  .assistant-box button:disabled{
    opacity:0.6;
    cursor:not-allowed;
  }
  .assistant-reply{
    min-height:2.5rem;
    border:1px solid var(--border);
    border-radius:12px;
    padding:10px;
    background:var(--panel);
    font-size:0.95rem;
    line-height:1.4;
  }
  #assistant-audio{
    width:100%;
  }

  /* ======== landscapeï¼ˆæ¨ªå‘ãï¼‰ã§å·¦å³ã‚«ãƒ¼ãƒ‰ã‚’å°ã•ãï¼†æ­£æ–¹å½¢ ======== */
  @media (orientation: landscape){
    /* 1ç”»é¢ã«åã‚ã‚‹ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç¦æ­¢ & å®‰å…¨é ˜åŸŸè€ƒæ…®ï¼‰ */
    html, body{ height:100svh; overflow:hidden; }
    body{
      padding: env(safe-area-inset-top, 0) env(safe-area-inset-right, 0)
               env(safe-area-inset-bottom, 0) env(safe-area-inset-left, 0);
    }

    /* æ­£æ–¹å½¢ã‚«ãƒ¼ãƒ‰ã®åŸºæº–ã‚µã‚¤ã‚ºï¼ˆvhå„ªå…ˆã§è‡ªå‹•ç¸®å°ã€vwã§ã‚‚ä¸Šé™ï¼‰ */
    :root{
      --side-card-vh: clamp(64px, 13.0vh, 120px);
      --side-card-size: min(18vw, var(--side-card-vh));
    }

    /* ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼šå·¦å³ã‚’ã‚„ã‚„ç‹­ã‚ã€ä¸­å¤®ã¯å¯å¤‰ */
    .layout{
      height:100%;
      max-width:none; margin:0;
      grid-template-columns: clamp(110px, 19vw, 220px) 1fr clamp(110px, 19vw, 220px);
      gap: 1.2vh;
      padding: 1.2vh;
    }

    .panel{
      border-radius: 1.2vh;
      padding: 1.0vh;
      gap: 1.0vh;
      box-shadow: 0 0.8vh 2.2vh rgba(255,255,255,.08);
      min-height:0; overflow:hidden;
    }

    /* ===== å·¦å³ãƒ‘ãƒãƒ«ã®ä¸­èº«ï¼šæ­£æ–¹å½¢åŒ– ===== */
    aside.panel.vstack{ align-items:center; }  /* æ­£æ–¹å½¢ã‚’ä¸­å¤®å¯„ã› */

    /* å¤©æ°—ï¼ˆç¾åœ¨ï¼30åˆ†å¾Œï¼1æ™‚é–“å¾Œï¼‰ */
    .wx-item{
      width: var(--side-card-size);
      aspect-ratio: 1 / 1;           /* æ­£æ–¹å½¢ï¼ */
      padding: min(1.1vh, 10px);
      display:flex; flex-direction:column; justify-content:center; align-items:center;
      flex: 0 0 auto;                /* ä¼¸ã³ç¸®ã¿ç¦æ­¢ */
    }

    /* ã‚»ãƒ³ã‚µãƒ¼ï¼ˆæ°—æ¸©ï¼æ¹¿åº¦ï¼‰ */
    #sensor-panel .kv{
      width: var(--side-card-size);
      aspect-ratio: 1 / 1;           /* æ­£æ–¹å½¢ï¼ */
      padding: min(1.1vh, 10px);
      display:flex; flex-direction:column; justify-content:center; align-items:center;
      flex: 0 0 auto;
    }

    /* ã‚¿ã‚¤ãƒˆãƒ«ãƒ»è£œåŠ©æ–‡å­—ã¯è‡ªå‹•ç¸®å° */
    .title{ font-size: clamp(0.9rem, 1.3vh, 1.05rem); text-align:center; }
    .muted, .kv .k, .wx-label{ font-size: clamp(0.72rem, 1.1vh, 0.95rem); text-align:center; }

    /* çµµæ–‡å­—ãƒ»æ•°å€¤ã¯æ­£æ–¹å½¢å†…ã§è¦‹ã‚„ã™ã */
    .wx-emoji{ font-size: clamp(1.1rem, 3vh, 2rem); line-height:1; }
    .kv .v{ font-size: clamp(1.0rem, 2.8vh, 1.7rem); margin-top: 0.3em; }

    /* çŸ¢å°ã¯çœã‚¹ãƒšãƒ¼ã‚¹ */
    .arrow{ height:auto; }
    .arrow svg{ width: min(2vh, 16px); height: min(2vh, 16px); }

    /* ä¸­å¤®ï¼ˆæ™‚è¨ˆï¼‰ã¯æ®‹ã‚Šã‚¹ãƒšãƒ¼ã‚¹ã§å¯å¤‰ */
    .center{ justify-content:flex-start; align-items:stretch; min-height:0; }
    .map-wrapper{ padding:min(1.3vh, 12px); border-radius:12px; }
    #map{ min-height:240px; }
    .datetime{ align-items:center; }
    .datetime #date{ font-size: clamp(0.9rem, 1.5vh, 1.1rem); }
    .datetime #clock{ font-size: clamp(1.8rem, 6vh, 3.2rem); letter-spacing: clamp(0.06rem, 0.35vh, 0.16rem); white-space:nowrap; }
  }
</style>
<body>

  <div class="layout">
    <!-- å·¦ï¼šå¤©æ°— -->
    <aside class="panel vstack">
      <div class="title" id="wx-location">å¤©æ°—æƒ…å ±ã‚’å–å¾—ä¸­...</div>
      <div id="wx-status" class="muted" style="text-align:center;">ä½ç½®æƒ…å ±ã‚’å–å¾—ä¸­â€¦</div>

      <div class="wx-item">
        <div class="wx-emoji" id="wx-now-emoji">--</div>
        <div class="wx-label">ç¾åœ¨</div>
      </div>

      <div class="arrow" aria-hidden="true">
        <svg viewBox="0 0 24 24"><path d="M12 5v14M12 19l-4-4m4 4l4-4"/></svg>
      </div>

      <div class="wx-item">
        <div class="wx-emoji" id="wx-30m-emoji">--</div>
        <div class="wx-label">30åˆ†å¾Œ</div>
      </div>

      <div class="arrow" aria-hidden="true">
        <svg viewBox="0 0 24 24"><path d="M12 5v14M12 19l-4-4m4 4l4-4"/></svg>
      </div>

      <div class="wx-item">
        <div class="wx-emoji" id="wx-1h-emoji">--</div>
        <div class="wx-label">1æ™‚é–“å¾Œ</div>
      </div>
    </aside>

    <!-- ä¸­å¤®ï¼šæ—¥ä»˜ãƒ»æ™‚è¨ˆ -->
    <main class="panel center">
      <div class="datetime">
        <div id="date">----å¹´--æœˆ--æ—¥ (--)</div>
        <div id="clock">--:--:--</div>
      </div>
      <div class="map-wrapper">
        <div id="map"></div>
        <div id="map-status" class="muted">GPSèª­ã¿è¾¼ã¿ä¸­â€¦</div>
      </div>
    </main>

    <!-- å³ï¼šã‚»ãƒ³ã‚µãƒ¼ -->
    <aside class="panel vstack" id="sensor-panel">
      <div class="kv"><div class="k">æ°—æ¸©(â„ƒ)</div><div class="v" id="temp-v">--</div></div>
      <div class="kv"><div class="k">æ¹¿åº¦(%)</div><div class="v" id="humi-v">--</div></div>
      <div class="kv"><div class="k">æµ·æŠœ(m)</div><div class="v" id="alt-v">--</div></div>
      <div class="muted" style="text-align:center;">æ›´æ–°: <code id="ts">-</code></div>
      <div id="status" class="muted" style="text-align:center;">èª­ã¿è¾¼ã¿ä¸­â€¦</div>
      <div class="assistant-box">
        <div class="title" style="font-size:0.9rem;">ãƒŸãƒ‹éŸ³å£°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ</div>
        <button id="assistant-btn">è©±ã—ã‹ã‘ã‚‹</button>
        <div id="assistant-status" class="muted">ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦éŒ²éŸ³ã‚’é–‹å§‹ã—ã¾ã™ã€‚</div>
        <div id="assistant-reply" class="assistant-reply">-</div>
        <audio id="assistant-audio" controls playsinline hidden></audio>
      </div>
    </aside>
  </div>

  <script
    src="https://cdn.jsdelivr.net/npm/ol@7.5.2/dist/ol.js"
    crossorigin="anonymous"
  ></script>
  <script>
    /* ===== è¨­å®š ===== */
    const API_BASE = window.location.origin;
    const USER_ID  = "02";
    const FIELDS   = "temperature_c,humidity_percent,altitude_m";
    const RANGE    = "-30d";
    const GPS_FIELDS = "latitude,longitude";
    const GPS_RANGE  = "-1h";
    const MAP_ANIMATION_MS = 600;

    /* â–¼â–¼â–¼ ç¥å¥ˆå·çœŒè—¤æ²¢å¸‚ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä½ç½®ã«è¨­å®š â–¼â–¼â–¼ */
    const FUJISAWA = { lat: 35.3389, lon: 139.4913 };
    const FALLBACK_PLACE = "ç¥å¥ˆå·çœŒè—¤æ²¢å¸‚";
    /* â–²â–²â–² ã“ã“ã¾ã§ â–²â–²â–² */

    /* ===== æ™‚è¨ˆ ===== */
    const dateEl = document.getElementById("date");
    const clockEl = document.getElementById("clock");
    function updateClock(){
      const now = new Date();
      const yyyy = now.getFullYear();
      const mm = String(now.getMonth()+1).padStart(2,"0");
      const dd = String(now.getDate()).padStart(2,"0");
      const days = ["æ—¥","æœˆ","ç«","æ°´","æœ¨","é‡‘","åœŸ"];
      const hh = String(now.getHours()).padStart(2,"0");
      const mi = String(now.getMinutes()).padStart(2,"0");
      const ss = String(now.getSeconds()).padStart(2,"0");
      dateEl.textContent = `${yyyy}å¹´${mm}æœˆ${dd}æ—¥ (${days[now.getDay()]})`;
      clockEl.textContent = `${hh}:${mi}:${ss}`;
    }
    setInterval(updateClock, 1000); updateClock();

    /* ===== å¤©æ°—ï¼ˆOpen-Meteo + Nominatimï¼‰ ===== */
    const wxLocation = document.getElementById("wx-location");
    const wxStatus = document.getElementById("wx-status");
    const nowEmoji = document.getElementById("wx-now-emoji");
    const m30Emoji = document.getElementById("wx-30m-emoji");
    const h1Emoji  = document.getElementById("wx-1h-emoji");

    function codeToEmoji(code){
      const c = Number(code);
      if ([0].includes(c)) return "â˜€ï¸";
      if ([1].includes(c)) return "ğŸŒ¤ï¸";
      if ([2].includes(c)) return "â›…ï¸";
      if ([3].includes(c)) return "â˜ï¸";
      if ([45,48].includes(c)) return "ğŸŒ«ï¸";
      if ([51,53,55,56,57].includes(c)) return "ğŸŒ¦ï¸";
      if ([61,63,65,80,81,82].includes(c)) return "ğŸŒ§ï¸";
      if ([71,73,75,77,85,86].includes(c)) return "â„ï¸";
      if ([95,96,99].includes(c)) return "â›ˆï¸";
      return "â“";
    }

    // å–å¾—æˆåŠŸã§ã‚‚ç²¾åº¦ãŒæ‚ªã‘ã‚Œã°è—¤æ²¢å¸‚ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    const ACCURACY_THRESHOLD_M = 10000;
    function getPositionOrFallback(){
      return new Promise((resolve)=>{
        if(!navigator.geolocation) return resolve(FUJISAWA);
        navigator.geolocation.getCurrentPosition(
          pos => {
            const { latitude, longitude, accuracy } = pos.coords || {};
            if (typeof accuracy !== "number" || !isFinite(accuracy) || accuracy > ACCURACY_THRESHOLD_M) {
              resolve(FUJISAWA);
            } else {
              resolve({ lat: latitude, lon: longitude });
            }
          },
          ()  => resolve(FUJISAWA),
          { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 }
        );
      });
    }

    async function reverseGeocodeJapanese(lat, lon){
      try{
        const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}&accept-language=ja`;
        const data = await fetch(url).then(r=>r.json());
        const a = data.address || {};
        return a.city || a.town || a.village || a.suburb || a.county || a.state || FALLBACK_PLACE;
      }catch{ return FALLBACK_PLACE; }
    }

    async function fetchWeather(){
      try{
        wxStatus.textContent = "ä½ç½®æƒ…å ±ã‚’å–å¾—ä¸­â€¦";
        const {lat, lon} = await getPositionOrFallback();
        const place = await reverseGeocodeJapanese(lat, lon);
        wxLocation.textContent = `${place}ã®å¤©æ°—`;
        wxStatus.textContent = "å¤©æ°—ã‚’å–å¾—ä¸­â€¦";

        const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=weather_code&hourly=weather_code&timezone=auto`;
        const j = await fetch(url).then(r=>r.json());

        const cur = j.current?.weather_code;
        nowEmoji.textContent  = codeToEmoji(cur);

        const times = j.hourly?.time || [];
        const codes = j.hourly?.weather_code || [];
        const now = new Date();
        const target30 = new Date(now.getTime() + 30*60*1000);
        const target60 = new Date(now.getTime() + 60*60*1000);
        const idx30 = times.findIndex(t => new Date(t) >= target30);
        const idx60 = times.findIndex(t => new Date(t) >= target60);
        m30Emoji.textContent = (idx30 >= 0) ? codeToEmoji(codes[idx30]) : "â€”";
        h1Emoji.textContent  = (idx60 >= 0) ? codeToEmoji(codes[idx60])  : "â€”";

        wxStatus.textContent = "OK";
      }catch(e){
        wxStatus.textContent = "å¤©æ°—å–å¾—ã‚¨ãƒ©ãƒ¼: " + e.message;
        nowEmoji.textContent = m30Emoji.textContent = h1Emoji.textContent = "â“";
      }
    }

    /* ===== ãƒãƒƒãƒ—ï¼ˆGPSåº§æ¨™ï¼‰ ===== */
    function ensureMarkerStyle(){
      if (!window.ol || markerStyle) return markerStyle;
      markerStyle = new ol.style.Style({
        image: new ol.style.Circle({
          radius: 8,
          fill: new ol.style.Fill({ color: "#00bfff" }),
          stroke: new ol.style.Stroke({ color: "#083150", width: 2 }),
        }),
      });
      return markerStyle;
    }

    function createMap(lngLat){
      const center = ol.proj.fromLonLat(lngLat);
      markerLayer = new ol.layer.Vector({
        source: new ol.source.Vector(),
      });
      mapInstance = new ol.Map({
        target: mapEl,
        layers: [
          new ol.layer.Tile({ source: new ol.source.OSM() }),
          markerLayer,
        ],
        view: new ol.View({
          center,
          zoom: 16,
          minZoom: 2,
          maxZoom: 19,
        }),
        controls: ol.control.defaults.defaults({ attribution: true }),
      });
      markerFeature = new ol.Feature({ geometry: new ol.geom.Point(center) });
      markerFeature.setStyle(ensureMarkerStyle());
      markerLayer.getSource().addFeature(markerFeature);
    }

    function updateMapView(lat, lon){
      if (!window.ol || !mapEl){
        if (mapStatus){
          mapStatus.textContent = "ãƒãƒƒãƒ—ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’èª­ã¿è¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸ";
        }
        return;
      }
      const lngLat = [Number(lon), Number(lat)];
      if (!mapInstance){
        createMap(lngLat);
        return;
      }
      const coords = ol.proj.fromLonLat(lngLat);
      const view = mapInstance.getView();
      view.animate({ center: coords, duration: MAP_ANIMATION_MS });
      if (!markerFeature){
        markerFeature = new ol.Feature({ geometry: new ol.geom.Point(coords) });
        markerFeature.setStyle(ensureMarkerStyle());
        markerLayer.getSource().addFeature(markerFeature);
      }else{
        markerFeature.getGeometry().setCoordinates(coords);
      }
    }

    async function fetchGps(){
      if (!mapStatus) return;
      mapStatus.textContent = "GPSèª­ã¿è¾¼ã¿ä¸­â€¦";
      try{
        const url = `${API_BASE}/api/latest_gps?user_id=${encodeURIComponent(USER_ID)}&fields=${encodeURIComponent(GPS_FIELDS)}&time_range=${encodeURIComponent(GPS_RANGE)}`;
        const res = await fetch(url);
        if(!res.ok) throw new Error(`${res.status} ${res.statusText}`);
        const json = await res.json();

        const { lat, lon, timestamp } = json;
        if (lat == null || lon == null) throw new Error("åº§æ¨™ãŒå–å¾—ã§ãã¾ã›ã‚“");
        updateMapView(Number(lat), Number(lon));
        mapStatus.textContent = `GPSæ›´æ–°: ${formatTimeToJP(timestamp)}`;
      }catch(e){
        mapStatus.textContent = "GPSã‚¨ãƒ©ãƒ¼: " + e.message + " / ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä½ç½®ã‚’è¡¨ç¤ºã—ã¾ã™";
        updateMapView(FUJISAWA.lat, FUJISAWA.lon);
      }
    }

    /* ===== ã‚»ãƒ³ã‚µãƒ¼æƒ…å ± ===== */
    const statusEl = document.getElementById("status");
    const tsEl     = document.getElementById("ts");
    const tempV    = document.getElementById("temp-v");
    const humiV    = document.getElementById("humi-v");
    const altV     = document.getElementById("alt-v");
    const mapEl    = document.getElementById("map");
    const mapStatus = document.getElementById("map-status");
    let mapInstance = null;
    let markerLayer = null;
    let markerFeature = null;
    let markerStyle = null;

    function formatTimeToJP(ts) {
      if (!ts) return "-";
      const d = new Date(ts);
      if (isNaN(d)) return ts;
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const dd = String(d.getDate()).padStart(2, "0");
      const hh = String(d.getHours()).padStart(2, "0");
      const mi = String(d.getMinutes()).padStart(2, "0");
      return `${yyyy}/${mm}/${dd} ${hh}:${mi}æ™‚ç‚¹`;
    }

    async function fetchLatest(){
      statusEl.textContent = "èª­ã¿è¾¼ã¿ä¸­â€¦";
      try{
        const url = `${API_BASE}/api/latest?user_id=${encodeURIComponent(USER_ID)}&fields=${encodeURIComponent(FIELDS)}&time_range=${encodeURIComponent(RANGE)}`;
        const res = await fetch(url);
        if(!res.ok) throw new Error(`${res.status} ${res.statusText}`);
        const json = await res.json();

        tsEl.textContent  = formatTimeToJP(json.timestamp);

        const data = json.data || {};
        if (data.temperature_c != null) tempV.textContent = Number(data.temperature_c).toFixed(1);
        else tempV.textContent = "â€”";
        if (data.humidity_percent != null) humiV.textContent = Math.round(Number(data.humidity_percent));
        else humiV.textContent = "â€”";
        if (data.altitude_m != null) altV.textContent = Number(data.altitude_m).toFixed(1);
        else altV.textContent = "â€”";

        statusEl.textContent = "OK";
      }catch(e){
        statusEl.textContent = "ã‚¨ãƒ©ãƒ¼: " + e.message;
        tempV.textContent = humiV.textContent = altV.textContent = "â€”";
      }
    }

    /* ===== ãƒŸãƒ‹éŸ³å£°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ ===== */
    const assistantBtn = document.getElementById("assistant-btn");
    const assistantStatus = document.getElementById("assistant-status");
    const assistantReply = document.getElementById("assistant-reply");
    const assistantAudio = document.getElementById("assistant-audio");

    const vadConfig = {
      threshold: 0.015,
      minSpeechMs: 200,
      minSilenceMs: 700,
    };
    const vadState = {
      active: false,
      speechMs: 0,
      silenceMs: 0,
      frameMs: 0,
      triggered: false,
    };

    const recorderState = {
      recording: false,
      stopping: false,
      buffers: [],
      audioContext: null,
      processor: null,
      source: null,
      stream: null,
      sampleRate: 16000,
    };

    function resetAssistantUI(){
      assistantBtn.disabled = false;
      assistantBtn.textContent = "è©±ã—ã‹ã‘ã‚‹";
    }

    function resetVadState(){
      vadState.active = false;
      vadState.triggered = false;
      vadState.speechMs = 0;
      vadState.silenceMs = 0;
    }

    function cleanupRecordingNodes(){
      if (recorderState.processor){
        recorderState.processor.disconnect();
        recorderState.processor.onaudioprocess = null;
      }
      if (recorderState.source){
        recorderState.source.disconnect();
      }
      if (recorderState.stream){
        recorderState.stream.getTracks().forEach((track)=>track.stop());
      }
      if (recorderState.audioContext){
        recorderState.audioContext.close();
      }
      recorderState.processor = null;
      recorderState.source = null;
      recorderState.stream = null;
      recorderState.audioContext = null;
      resetVadState();
    }

    function mergeBuffers(buffers){
      const totalLength = buffers.reduce((sum, buf)=>sum + buf.length, 0);
      const result = new Float32Array(totalLength);
      let offset = 0;
      for (const buf of buffers){
        result.set(buf, offset);
        offset += buf.length;
      }
      return result;
    }

    function floatTo16BitPCM(float32Array){
      const buffer = new ArrayBuffer(float32Array.length * 2);
      const view = new DataView(buffer);
      for (let i = 0; i < float32Array.length; i++){
        let s = Math.max(-1, Math.min(1, float32Array[i]));
        view.setInt16(i * 2, s < 0 ? s * 0x8000 : s * 0x7fff, true);
      }
      return buffer;
    }

    function encodeWav(samples, sampleRate){
      const buffer = new ArrayBuffer(44 + samples.length * 2);
      const view = new DataView(buffer);

      function writeString(offset, string){
        for (let i = 0; i < string.length; i++){
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      }

      const pcmBuffer = floatTo16BitPCM(samples);

      writeString(0, "RIFF");
      view.setUint32(4, 36 + samples.length * 2, true);
      writeString(8, "WAVE");
      writeString(12, "fmt ");
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, 1, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * 2, true);
      view.setUint16(32, 2, true);
      view.setUint16(34, 16, true);
      writeString(36, "data");
      view.setUint32(40, samples.length * 2, true);

      const wavBytes = new Uint8Array(buffer);
      wavBytes.set(new Uint8Array(pcmBuffer), 44);
      return new Blob([wavBytes], { type: "audio/wav" });
    }

    async function uploadAssistantAudio(blob){
      const formData = new FormData();
      formData.append("file", blob, "recording.wav");
      assistantStatus.textContent = "ã‚µãƒ¼ãƒãƒ¼ã¸é€ä¿¡ä¸­â€¦";
      try{
        const res = await fetch(`${API_BASE}/api/assistant/talk`, {
          method: "POST",
          body: formData,
        });
        if (!res.ok){
          const msg = await res.text();
          throw new Error(msg || `HTTP ${res.status}`);
        }
        const data = await res.json();
        assistantStatus.textContent = data.message || "å®Œäº†";
        assistantReply.textContent = data.reply || "(å¿œç­”ãªã—)";
        if (data.audio_base64){
          assistantAudio.hidden = false;
          assistantAudio.src = `data:${data.audio_mime || "audio/wav"};base64,${data.audio_base64}`;
          const playPromise = assistantAudio.play();
          if (playPromise){
            playPromise.catch(()=>{});
          }
        }else{
          assistantAudio.hidden = true;
          assistantAudio.removeAttribute("src");
        }
      }catch(err){
        assistantStatus.textContent = "ã‚¨ãƒ©ãƒ¼: " + err.message;
      }
    }

    async function stopAssistantRecording(autoStop = false){
      if (!recorderState.recording || recorderState.stopping){
        return;
      }
      recorderState.recording = false;
      recorderState.stopping = true;
      assistantBtn.disabled = true;
      assistantBtn.textContent = autoStop ? "è‡ªå‹•åœæ­¢ä¸­â€¦" : "å‡¦ç†ä¸­â€¦";
      cleanupRecordingNodes();
      const merged = mergeBuffers(recorderState.buffers);
      recorderState.buffers = [];
      if (!merged.length){
        assistantStatus.textContent = "éŒ²éŸ³ãŒçŸ­ã™ãã¾ã—ãŸã€‚å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚";
        resetAssistantUI();
        recorderState.stopping = false;
        return;
      }
      const wavBlob = encodeWav(merged, recorderState.sampleRate);
      await uploadAssistantAudio(wavBlob);
      resetAssistantUI();
      recorderState.stopping = false;
    }

    async function startAssistantRecording(){
      try{
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(stream);
        const processor = audioContext.createScriptProcessor(4096, 1, 1);
        recorderState.stream = stream;
        recorderState.audioContext = audioContext;
        recorderState.source = source;
        recorderState.processor = processor;
        recorderState.sampleRate = audioContext.sampleRate;
        recorderState.buffers = [];
        vadState.frameMs = (processor.bufferSize / recorderState.sampleRate) * 1000;
        resetVadState();
        processor.onaudioprocess = (event)=>{
          const channelData = event.inputBuffer.getChannelData(0);
          recorderState.buffers.push(new Float32Array(channelData));
          let sumSquares = 0;
          for (let i = 0; i < channelData.length; i += 1){
            const sample = channelData[i];
            sumSquares += sample * sample;
          }
          const rms = Math.sqrt(sumSquares / channelData.length);
          const isSpeech = rms >= vadConfig.threshold;
          if (isSpeech){
            vadState.speechMs += vadState.frameMs;
            vadState.silenceMs = 0;
            if (!vadState.triggered && vadState.speechMs >= vadConfig.minSpeechMs){
              vadState.triggered = true;
              assistantStatus.textContent = "éŸ³å£°æ¤œå‡º: è©±ã—ç¶šã‘ã¦ãã ã•ã„ã€‚";
            }
          } else if (vadState.triggered){
            vadState.silenceMs += vadState.frameMs;
            if (vadState.silenceMs >= vadConfig.minSilenceMs){
              vadState.triggered = false;
              assistantStatus.textContent = "ç„¡éŸ³æ¤œå‡º: é€ä¿¡ã—ã¾ã™â€¦";
              void stopAssistantRecording(true);
            }
          }
        };
        source.connect(processor);
        processor.connect(audioContext.destination);
        recorderState.recording = true;
        assistantBtn.textContent = "éŒ²éŸ³åœæ­¢";
        assistantStatus.textContent = "éŒ²éŸ³ä¸­â€¦ ã‚‚ã†ä¸€åº¦ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨é€ä¿¡ã—ã¾ã™ã€‚";
        assistantReply.textContent = "-";
        assistantAudio.hidden = true;
        assistantAudio.removeAttribute("src");
        assistantBtn.disabled = false;
      }catch(err){
        assistantStatus.textContent = "ãƒã‚¤ã‚¯å–å¾—ã«å¤±æ•—: " + err.message;
        resetAssistantUI();
      }
    }

    if (assistantBtn){
      if (!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia)){
        assistantBtn.disabled = true;
        assistantStatus.textContent = "ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯ãƒã‚¤ã‚¯ã‚’åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚";
      }
      assistantBtn.addEventListener("click", async ()=>{
        if (!recorderState.recording){
          assistantBtn.disabled = true;
          assistantBtn.textContent = "ãƒã‚¤ã‚¯æ¥ç¶šä¸­â€¦";
          await startAssistantRecording();
        }else{
          await stopAssistantRecording(false);
        }
      });
    }

    document.addEventListener("DOMContentLoaded", ()=>{
      fetchWeather(); fetchLatest(); fetchGps();
      window._timer_sensor  = setInterval(fetchLatest, 30_000);
      window._timer_weather = setInterval(fetchWeather, 300_000);
      window._timer_gps     = setInterval(fetchGps, 60_000);
    });
  </script>
</body>
</html>
